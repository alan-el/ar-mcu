/******************************************************************************
  * @project: LT8619C
  * @file: lt8619.c
  * @author: 
  * @company: LONTIUM COPYRIGHT and CONFIDENTIAL
  * @date: 2020.9.30
		***Differences from version 1.0***
		1. Added LT8619C_LvdspllLock_Det() function when phase adjust enable;
		2. Added U5C PIN68 output PCLK configuration;
		3. Added 2 port LVDS output detection function;
		4. Modify RX module configuration logic.
******************************************************************************/			
		/***Differences from version 2.3***
		1. Modify LT8619C_LvdspllLock_Det() function in all application;
		2. Keep lvdspll reset after clk stable.	
******************************************************************************/

#include "nrf_drv_twi.h"
#include "nrf_error.h"
#include "nrf_delay.h"
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"

#include "lt8619c.h"
//#define DDR_CLK
//#define HDMI_WriteI2C_Byte Write_I2C_Byte
//#define HDMI_ReadI2C_Byte Read_I2C_Byte
//#define Debug_DispStrNum
//#define  NRF_LOG_INFO
//#define Debug_DispNum 
//#define HDMI_WriteI2C_ByteN Write_I2C_ByteN

/* TWI instance ID */
#define TWI_INSTANCE_ID     0

/* TWI instance. */
static const nrf_drv_twi_t m_twi = NRF_DRV_TWI_INSTANCE(TWI_INSTANCE_ID);


_LT8619C_RXStatus LT8619C_RXStatus, *pLT8619C_RXStatus;

u16 h_active, v_active;
u16 h_syncwidth, v_syncwidth;
u16 h_bkporch, v_bkporch;
u16 h_total, v_total;
u8  h_syncpol, v_syncpol,color;
u32 frame_counter;
 u8 ONCHIP_EDID[256]={
//1920*1080
0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0e, 0xd4, 0x32, 0x31, 0x00, 0x88, 0x88, 0x88,
0x20, 0x1c, 0x01, 0x03, 0x80, 0x0c, 0x07, 0x78, 0x0a, 0x0d, 0xc9, 0xa0, 0x57, 0x47, 0x98, 0x27,
0x12, 0x48, 0x4c, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
0x45, 0x00, 0x80, 0x38, 0x74, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x0a,
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
0x00, 0x4C, 0x6F, 0x6E, 0x74, 0x69, 0x75, 0x6D, 0x20, 0x73, 0x65, 0x6D, 0x69, 0x20, 0x01, 0xf5,

0x02, 0x03, 0x12, 0xf1, 0x23, 0x09, 0x04, 0x01, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0c, 0x00,
0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf

};
const  video_timing lcd_timing =
{
//pix_clk/kHz, hfp, hs, hbp,hact,htotal,vfp, vs, vbp,vact, vtotal
//71000,48,32,80,1280,1440,3,6,14,800,823
//67032,55,40,50,1280,1425,8,2,6,768,784
//194000,136,200,336,1920,2592,3,6,36,1200,1245
	
//297000, 88, 44, 148, 1920, 2200,  4,  5,  36, 1080, 1125	
//99000,88, 44, 148, 1920, 2200,5,5,20,720,750	
	
//74250,1760,40,220,1280,3300,5,5,20,720,750 //CEA-861-F
//74250,110,40,220,1280,1650,5,5,20,720,750
//107964,48,112, 248,1280,  1688,  20,  6, 16, 1024, 1066
148500, 88, 44, 148, 1920, 2200,  4,  5,  36, 1080, 1125 //1080P60
//123750, 88, 44, 148, 1920, 2200,  4,  5,  36, 1080, 1125 //1080P50
//74250, 88, 44, 148, 1920, 2200,  4,  5,  36, 1080, 1125 //1080P30
//61875, 88, 44, 148, 1920, 2200,  4,  5,  36, 1080, 1125 //1080P25
//74316, 88, 44, 148, 1920, 2200,  3,  5,  15, 540, 563 //1080i60
//61930, 88, 44, 148, 1920, 2200,  3,  5,  15, 540, 563 //1080i50
//70000, 50, 10, 12, 800, 872, 6, 6, 14, 1280, 1306
//26957,24,126, 138,1440,  1728, 2,  3, 19, 288, 312//1440*288/50  
//61875, 88, 44, 148, 1920, 2200, 4, 5, 36, 1080, 1125
//74250,110,40, 220,1280,  1650,  5,  5,  20, 720,   750 //720P60
//61875,110,40, 220,1280,  1650,  5,  5,  20, 720,   750 //720P50
//37125,110,40, 220,1280,  1650,  5,  5,  20, 720,   750 //720P30
//31000,110,40, 220,1280,  1650,  5,  5,  20, 720,   750 //720P25
//85500,70,143, 213, 1366,  1792,  3,  3,  24, 768, 798
//12600,16,96, 48, 640,  800,  10,  2,  33, 480, 525 //640*480 30
//30000,35,15, 35, 480,  565,  35,  10,  35, 800, 880
//70000, 34, 20, 34, 1366, 1454, 10, 5, 10, 768, 793
//26230, 32, 16, 48, 800, 896, 4, 2, 2, 480, 488
//83500, 72, 128, 200, 1280, 1680, 3, 6, 22, 800, 831
//26200, 16, 16, 16, 280, 528, 8, 8, 8, 800, 824
//297000,176,88, 296,3840,  4400,  8,  10, 72, 2160, 2250 //4k30
//265000,110,70, 180,2560,  2920, 6,  8, 54, 1440, 1508//2560*1440 60
//26230, 32, 16, 48, 800, 896, 4, 2, 2, 480, 488
//51200,160,20, 140,1024,  1344,  12,  3, 20, 600, 635
// 25200,40,20,60,720,840,5,5,10,480,500
//65000,24,136, 160,1024,  1344,  3,  6, 29, 768, 806
//25200,36,72,108,720,936,1,3,42,400,446
};

void lt8619c_i2c_init(void)
{
    ret_code_t err_code;
    const nrf_drv_twi_config_t config = 
    {
        .scl                = LT8619C_I2C_SCL_PIN_NUM,
        .sda                = LT8619C_I2C_SDA_PIN_NUM,
        .frequency          = NRF_DRV_TWI_FREQ_100K,
        .interrupt_priority = APP_IRQ_PRIORITY_HIGH,
        .clear_bus_init     = false
    };
    
    err_code = nrf_drv_twi_init(&m_twi, &config, NULL, NULL);
    APP_ERROR_CHECK(err_code);
    
    nrf_drv_twi_enable(&m_twi);
}

void HDMI_WriteI2C_Byte(const u8 reg_addr, const u8 data)
{
    ret_code_t err_code;
    
    u8 send_data[2] = {reg_addr, data};
    
    err_code = nrf_drv_twi_tx(&m_twi, LT8619C_I2C_ADDR, send_data, 2, false);
    APP_ERROR_CHECK(err_code);
}

void HDMI_WriteI2C_ByteN(const u8 reg_addr, const u8 *pdata, u16 length)
{
    ret_code_t err_code;

    err_code = nrf_drv_twi_tx(&m_twi, LT8619C_I2C_ADDR, &reg_addr, 1, true);
    APP_ERROR_CHECK(err_code);

    u8 group = length / 255;
    u8 extra = length % 255;
    
    for(int i = 0; i < group; i++)
    {
        err_code = nrf_drv_twi_tx(&m_twi, LT8619C_I2C_ADDR, pdata + i * 255, 255, true);
        APP_ERROR_CHECK(err_code);
    }

    err_code = nrf_drv_twi_tx(&m_twi, LT8619C_I2C_ADDR, pdata + group * 255, extra, false);
    APP_ERROR_CHECK(err_code);
}

u8 HDMI_ReadI2C_Byte(const u8 reg_addr)
{
    ret_code_t err_code;
    u8 data;
    err_code = nrf_drv_twi_tx(&m_twi, LT8619C_I2C_ADDR, &reg_addr, 1, false);
    APP_ERROR_CHECK(err_code);
    
    err_code = nrf_drv_twi_rx(&m_twi, LT8619C_I2C_ADDR, &data, 1);
    APP_ERROR_CHECK(err_code);

    return data;
}

void LT8619C_SetHPD(Pin_Status level)
{
 
 HDMI_WriteI2C_Byte(0xFF,0x80);
    if( level )
    {
        HDMI_WriteI2C_Byte(0x06,HDMI_ReadI2C_Byte(0x06)|0x08);
    }
    else
    {
        HDMI_WriteI2C_Byte(0x06,HDMI_ReadI2C_Byte(0x06)&0xf7);
    }
}

void LT8619C_EDID_Dtb_Block_Calc(u8 *Pbuf,const video_timing *Timing)
{
	u16 Hblanking=0,Vblanking;
	u16 pix_clk;
	pix_clk=Timing->pix_clk/10;
	if(Pbuf==NULL || Timing==NULL)
	  return;
	Hblanking=Timing->hfp+Timing->hs+Timing->hbp;//H blanking
	Vblanking=Timing->vfp +Timing->vs+Timing->vbp;//V blanking
	//Debug_DispStrNum("\r\nPbuf[0]=",Pbuf[0]);
	Pbuf[0]=pix_clk%256;//pix_clock low
	Pbuf[1]=pix_clk/256;//pix_clock high
	Pbuf[2]=Timing->hact%256;//hact low
	Pbuf[3]=Hblanking%256;//H blanking low
	Pbuf[4]=((Timing->hact/256)<<4)+Hblanking/256;//Hact : Hblank
	Pbuf[5]=Timing->vact%256;//vact low
	Pbuf[6]=Vblanking%256;//V blanking low
	Pbuf[7]=((Timing->vact/256)<<4)+Vblanking/256;//Hact : Hblank
	Pbuf[8]=Timing->hfp%256;//H sync offset low
	Pbuf[9]=Timing->hs%256;//H sync width low
	Pbuf[10]=((Timing->vfp%256)<<4)+Timing->vs%256;
	Pbuf[11]=((Timing->hfp/256)<<6)+((Timing->hs/256)<<4)+
					 ((Timing->vfp/256)<<2)+(Timing->vs/256);
	Pbuf[17]=0x1e;//progress V+ H+ 
}
u8 LT8619C_EDID_Check_Sum(u8 block,u8 *buf)
{
	u8 i = 0, CheckSum = 0;
	u8 *pbuf = buf + 128*block;
	if(pbuf==NULL||(pbuf+127)==NULL)
		return 0;
	for ( i = 0, CheckSum = 0 ; i < 127 ; i++ )
	{
		CheckSum += pbuf[i] ;
		CheckSum %=256 ;
	}
	CheckSum=256-CheckSum;
	return CheckSum;
}

void LT8619C_EDIDSet(const u8 * EDID_Buffer)
{
 
    HDMI_WriteI2C_Byte(0xFF,0x80);
    HDMI_WriteI2C_Byte(0x8E,0x07);
    HDMI_WriteI2C_Byte(0x8F,0x00);
   if(EDID_Buffer==NULL)
      HDMI_WriteI2C_ByteN(0x90, &ONCHIP_EDID[0], 256);
   else
   	HDMI_WriteI2C_ByteN(0x90, EDID_Buffer, 256);
    HDMI_WriteI2C_Byte(0x8E,0x02);

}


bool LT8619C_LoadHDCPKey(void)
{
    u8 flag_load_key_done = 0, loop_cnt = 0;

    HDMI_WriteI2C_Byte(0xFF,0x80);
    HDMI_WriteI2C_Byte(0xb2,0x50);
    HDMI_WriteI2C_Byte(0xa3,0x77);
    while( loop_cnt <= 5 ) //wait load hdcp key done.
    {
        loop_cnt++;
        nrf_delay_ms(50);
        flag_load_key_done = HDMI_ReadI2C_Byte(0xc0)&0x08;
        if(flag_load_key_done)
        {
            break;
        }
    }
	  HDMI_WriteI2C_Byte(0xb2,0xd0);
    HDMI_WriteI2C_Byte(0xa3,0x57);
    if(flag_load_key_done)
    {
        NRF_LOG_INFO("\r\nLoad KEY done^_^");
        return TRUE;
    }
    else
    {
        NRF_LOG_INFO("\r\nLoad KEY error#####");
        return FALSE;
    }
}


void LT8619C_Rx_Eq_Mode_Config( void )
{
	HDMI_WriteI2C_Byte( 0xFF, 0x80 );
//	PresentBank = 0x80;
	HDMI_WriteI2C_Byte( 0x23, 0x11 );
	HDMI_WriteI2C_Byte( 0x2D, 0x02 );//index
	HDMI_WriteI2C_Byte( 0x2E, 0x02 );//index
	HDMI_WriteI2C_Byte( 0x2F, 0x02 );//index
}

void LT8619C_RX_EQ_Setting( void )
{
	HDMI_WriteI2C_Byte( 0xff, 0x80 );
//	PresentBank = 0x80;
	HDMI_WriteI2C_Byte( 0x28, 0x11 );       /* [7:4]=RGD_SW_CDR_FILT_SET=0x1,[3:0]=RGD_EQ3_SET_LOAD=0x4 */
	HDMI_WriteI2C_Byte( 0x29, 0x42 );       /*RGD_EQ1_SET_LOAD=0xf4 */
	HDMI_WriteI2C_Byte( 0x2b, 0x41 );       /*[7:6]=RGD_CLK_DET_CRIT=0x1,[4:0]=RGD_EQ_INDEX_LOAD=0x01 */
	HDMI_WriteI2C_Byte( 0x29, 0x7c );
	HDMI_WriteI2C_Byte( 0x2b, 0x42 );
	HDMI_WriteI2C_Byte( 0x29, 0xd4 );
	HDMI_WriteI2C_Byte( 0x2b, 0x43 );
	HDMI_WriteI2C_Byte( 0x29, 0x84 );
	HDMI_WriteI2C_Byte( 0x2b, 0x44 );
	HDMI_WriteI2C_Byte( 0x29, 0x18 );
	HDMI_WriteI2C_Byte( 0x2b, 0x45 );
	HDMI_WriteI2C_Byte( 0x29, 0x48 );
	HDMI_WriteI2C_Byte( 0x2b, 0x46 );
	HDMI_WriteI2C_Byte( 0x29, 0xb0 );
	HDMI_WriteI2C_Byte( 0x2b, 0x47 );
	HDMI_WriteI2C_Byte( 0x29, 0xd0 );
	HDMI_WriteI2C_Byte( 0x2b, 0x48 );
	HDMI_WriteI2C_Byte( 0x29, 0x90 );
	HDMI_WriteI2C_Byte( 0x2b, 0x49 );
	HDMI_WriteI2C_Byte( 0x29, 0xe0 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4a );
	HDMI_WriteI2C_Byte( 0x29, 0x60 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4b );
	HDMI_WriteI2C_Byte( 0x29, 0x20 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4c );
	HDMI_WriteI2C_Byte( 0x28, 0xf1 );/* [7:4]=RGD_SW_CDR_FILT_SET=0xf */
	HDMI_WriteI2C_Byte( 0x29, 0xc0 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4d );
	HDMI_WriteI2C_Byte( 0x29, 0x40 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4e );
	HDMI_WriteI2C_Byte( 0x29, 0x80 );
	HDMI_WriteI2C_Byte( 0x2b, 0x4f );
	HDMI_WriteI2C_Byte( 0x28, 0xf1 );
	HDMI_WriteI2C_Byte( 0x29, 0x3e );
	HDMI_WriteI2C_Byte( 0x2b, 0x40 );
	/*HDMI_WriteI2C_Byte( 0x2C, 0x25 );       / * [7:6]=RGD_FREQ_CHG_CRIT=0x0 * / */
	HDMI_WriteI2C_Byte( 0x1E, 0x1F );       /* [5]=RGD_CDR_GEAR_EN=0x0 */
	HDMI_WriteI2C_Byte( 0x1F, 0x20 );       /* [7:4]=RGD_CDR_LOCK_CRIT=0x2 */
	HDMI_WriteI2C_Byte( 0x2A, 0x0B );
	HDMI_WriteI2C_Byte( 0x24, 0xd0 );
	HDMI_WriteI2C_Byte( 0x25, 0xb0 );
}


void LT8619C_RXInit(void)
{
    HDMI_WriteI2C_Byte(0xFF,0x80);
    HDMI_WriteI2C_Byte(0x2c,HDMI_ReadI2C_Byte(0x2c)|0x30);  //RGD_CLK_STABLE_OPT[1:0]
    HDMI_WriteI2C_Byte(0xFF,0x60);
		HDMI_WriteI2C_Byte(0x04,0xF2);
		HDMI_WriteI2C_Byte(0x83,0x3F);
    HDMI_WriteI2C_Byte(0x80,0x08);  //use xtal_clk as sys_clk.
		#ifdef DDR_CLK
			HDMI_WriteI2C_Byte(0xa4,0x14);//0x10:SDR clk,0x14: DDR clk
		#else
			HDMI_WriteI2C_Byte(0xa4,0x10);//0x10:SDR clk,0x14: DDR clk
		#endif
	
	  #if 0
		LT8619C_Rx_Eq_Mode_Config();// RX EQ adjust
		LT8619C_RX_EQ_Setting(); 
	  #endif
	
    NRF_LOG_INFO("\r\nLT8619C OUTPUT_MODE: ");
    if( LT8619C_OUTPUTMODE == OUTPUT_RGB888)
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_RGB888");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c

        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x00);//0x07//00
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
		
		else if(  LT8619C_OUTPUTMODE == OUTPUT_YCBCR444 )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_YCBCR444");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x07);
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT1120_16BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT1120_16BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);//b0 1 2x / 0 1x ref clock as BT clock
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29);//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x33);
		
        HDMI_WriteI2C_Byte(0x6d,0x00);//0x00=YC no swap; 0x08=YC swap
        //HDMI_WriteI2C_Byte(0x6d,0x08);//0x00=YC no swap; 0x08=YC swap
        
        HDMI_WriteI2C_Byte(0x6e,0x07);//low 16bit
//        HDMI_WriteI2C_Byte(0x6e,0x06); //high 16bit
    }
		
    else if( LT8619C_OUTPUTMODE == OUTPUT_RGB666)
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_RGB666");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
 
        //8bit to 6bit dither function
        HDMI_WriteI2C_Byte(0x5f,0x38);//0x00=no dither; 0x28=dither; 0x38=dither+round
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x07);//add bymarui
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
   else if( LT8619C_OUTPUTMODE == OUTPUT_RGB565)
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_RGB565");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
			
        //8bit to 6bit dither function
        HDMI_WriteI2C_Byte(0x5f,0x38);//0x00=no dither; 0x28=dither; 0x38=dither+round
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0xe0);
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
    else if(  LT8619C_OUTPUTMODE == OUTPUT_YCBCR422_16BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_YCBCR422_16BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x30:PIN68 switch to output PCLK; 0x60A3=0x44:Phase change enable;
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
			
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x00);
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
    else if(  LT8619C_OUTPUTMODE == OUTPUT_YCBCR422_20BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_YCBCR422_20BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
//        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x40);
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
    else if(  LT8619C_OUTPUTMODE == OUTPUT_YCBCR422_24BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_YCBCR422_24BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x60,0x00);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
//				HDMI_WriteI2C_Byte(0xa3,0x74); //0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        //RGB mapping control
        HDMI_WriteI2C_Byte(0x6d,0x20);
        //RGB high/low bit swap control
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }

    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT1120_20BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT1120_20BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
//        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29);//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x33);
        HDMI_WriteI2C_Byte(0x6d,0x00);//0x00=YC no swap; 0x08=YC swap
        //low 20bit
        HDMI_WriteI2C_Byte(0x6e,0x05);
        //high 20bit
        //HDMI_WriteI2C_Byte(0x6e,0x04);
    }
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT1120_24BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT1120_24BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x50);
//        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29);//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x33);
        HDMI_WriteI2C_Byte(0x6d,0x00);//0x00=YC no swap; 0x08=YC swap
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
   else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT656_8BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT656_8BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);//71marui
        HDMI_WriteI2C_Byte(0xa0,0x51);//b0 1 2x / 0 1x ref clock as BT clock
        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29);//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x34);//0x34 marui
    //low 8bit
//        HDMI_WriteI2C_Byte(0x6d,0x08);
//        HDMI_WriteI2C_Byte(0x6e,0x07);
		//middle 8bit
        HDMI_WriteI2C_Byte(0x6d,0x00);
        HDMI_WriteI2C_Byte(0x6e,0x07);
		//high 8bit
//        HDMI_WriteI2C_Byte(0x6d,0x00);
//        HDMI_WriteI2C_Byte(0x6e,0x06);
    }
		
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT656_10BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT656_10BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x51);
//        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
        HDMI_WriteI2C_Byte(0xa2,0x29); //Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x34);
        //low 10bit
        //HDMI_WriteI2C_Byte(0x6d,0x08);
        //HDMI_WriteI2C_Byte(0x6e,0x05);
        //middle-low 10bit
        //HDMI_WriteI2C_Byte(0x6d,0x08);
        //HDMI_WriteI2C_Byte(0x6e,0x04);
        //middle-high 10bit
        //HDMI_WriteI2C_Byte(0x6d,0x00);
        //HDMI_WriteI2C_Byte(0x6e,0x05);
        //high 10bit
        HDMI_WriteI2C_Byte(0x6d,0x00);
        HDMI_WriteI2C_Byte(0x6e,0x04);
    }
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_BT656_12BIT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_BT656_12BIT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
				HDMI_WriteI2C_Byte(0x6F,0x04);			
        HDMI_WriteI2C_Byte(0xa8,0x0f);
        HDMI_WriteI2C_Byte(0x07,0xff);
        HDMI_WriteI2C_Byte(0x96,0x71);
        HDMI_WriteI2C_Byte(0xa0,0x51);
//        HDMI_WriteI2C_Byte(0xa3,0x74);//0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68 switch to output PCLK(only use for U5C)
			  HDMI_WriteI2C_Byte(0xa2,0x29);//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
        HDMI_WriteI2C_Byte(0x60,0x34);
        //high 12bit
        HDMI_WriteI2C_Byte(0x6d,0x00);
        HDMI_WriteI2C_Byte(0x6e,0x00);
    }
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_LVDS_2_PORT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_LVDS_2_PORT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x06,0xe7);
        HDMI_WriteI2C_Byte(0x59,0x40);//bit7 for VESA/JEIDA mode; bit5 for DE/SYNC mode; bit4 for 6/8bit; bit1 for port swap
        HDMI_WriteI2C_Byte(0xa0,0x58);
        HDMI_WriteI2C_Byte(0xa4,0x01);
        HDMI_WriteI2C_Byte(0xa8,0x00);
        HDMI_WriteI2C_Byte(0xba,0x18);
        HDMI_WriteI2C_Byte(0xc0,0x18);
        HDMI_WriteI2C_Byte(0xb0,0x66);
        HDMI_WriteI2C_Byte(0xb1,0x66);
        HDMI_WriteI2C_Byte(0xb2,0x66);
        HDMI_WriteI2C_Byte(0xb3,0x66);
        HDMI_WriteI2C_Byte(0xb4,0x66);
        HDMI_WriteI2C_Byte(0xb5,0x41);
        HDMI_WriteI2C_Byte(0xb6,0x41);
        HDMI_WriteI2C_Byte(0xb7,0x41);
        HDMI_WriteI2C_Byte(0xb8,0x4c);
        HDMI_WriteI2C_Byte(0xb9,0x41);
        HDMI_WriteI2C_Byte(0xbb,0x41);
        HDMI_WriteI2C_Byte(0xbc,0x41);
        HDMI_WriteI2C_Byte(0xbd,0x41);
        HDMI_WriteI2C_Byte(0xbe,0x4c);
        HDMI_WriteI2C_Byte(0xbf,0x41);
        HDMI_WriteI2C_Byte(0xa0,0x18);
        HDMI_WriteI2C_Byte(0xa1,0xb0);
        HDMI_WriteI2C_Byte(0xa2,0x10);
        HDMI_WriteI2C_Byte(0x5c,0x01);//bit0=0:single port  bit0=1:dual port
    }
    else if(  LT8619C_OUTPUTMODE ==  OUTPUT_LVDS_1_PORT )
    {
        NRF_LOG_INFO("\r\nLT8619C set to OUTPUT_LVDS_1_PORT");
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x06,0xe7);
        HDMI_WriteI2C_Byte(0x59,0x40);//0xd0 bit7 for VESA/JEIDA mode; bit5 for DE/SYNC mode; bit4 for 6/8bit; bit1 for port swap
        HDMI_WriteI2C_Byte(0xa0,0x58);
        HDMI_WriteI2C_Byte(0xa4,0x00);
        HDMI_WriteI2C_Byte(0xa8,0x00);
        HDMI_WriteI2C_Byte(0xba,0x18);
        HDMI_WriteI2C_Byte(0xc0,0x18);
        HDMI_WriteI2C_Byte(0xb0,0x66);
        HDMI_WriteI2C_Byte(0xb1,0x66);
        HDMI_WriteI2C_Byte(0xb2,0x66);
        HDMI_WriteI2C_Byte(0xb3,0x66);
        HDMI_WriteI2C_Byte(0xb4,0x66);
        HDMI_WriteI2C_Byte(0xb5,0x41);
        HDMI_WriteI2C_Byte(0xb6,0x41);
        HDMI_WriteI2C_Byte(0xb7,0x41);
        HDMI_WriteI2C_Byte(0xb8,0x4c);
        HDMI_WriteI2C_Byte(0xb9,0x41);
        HDMI_WriteI2C_Byte(0xbb,0x41);
        HDMI_WriteI2C_Byte(0xbc,0x41);
        HDMI_WriteI2C_Byte(0xbd,0x41);
        HDMI_WriteI2C_Byte(0xbe,0x4c);
        HDMI_WriteI2C_Byte(0xbf,0x41);
        HDMI_WriteI2C_Byte(0xa0,0x18);
        HDMI_WriteI2C_Byte(0xa1,0xb0);
        HDMI_WriteI2C_Byte(0xa2,0x10);
        HDMI_WriteI2C_Byte(0x5c,0x00);//bit0=0:single port  bit0=1:dual port
    }

				HDMI_WriteI2C_Byte(0xff,0x60);
				HDMI_WriteI2C_Byte(0x0e,0xfd);	
				HDMI_WriteI2C_Byte(0x0e,0xff);
				HDMI_WriteI2C_Byte(0x0d,0xfc);	
				HDMI_WriteI2C_Byte(0x0d,0xff);
}

void LT8619C_Audio_Init(void)
{
	if (Audio_Input_Mode == I2S_2CH)
	{
	    NRF_LOG_INFO("\r\nAudio set to I2S_2CH");
		HDMI_WriteI2C_Byte(0xff,0x60);
		HDMI_WriteI2C_Byte(0x4c,0x00);
	}
	else if (Audio_Input_Mode == SPDIF)
	{
	    NRF_LOG_INFO("\r\nAudio set to SPDIF");
		HDMI_WriteI2C_Byte(0xff,0x60);
		HDMI_WriteI2C_Byte(0x4c,0x80);
	}

	HDMI_WriteI2C_Byte(0xff,0x80);
	HDMI_WriteI2C_Byte(0x5d,0xc9);
	HDMI_WriteI2C_Byte(0x08,0x80);
}

void LT8619C_RX_Reset(void)
{
	HDMI_WriteI2C_Byte(0xFF,0x60);
	HDMI_WriteI2C_Byte(0x0E,0xBF);													/*reset RXPLL */
	HDMI_WriteI2C_Byte(0x09,0xFD);													/*reset RXPLL Lock det*/
	nrf_delay_ms(5);					
	HDMI_WriteI2C_Byte(0x0E,0xFF);													/*release RXPLL */
	HDMI_WriteI2C_Byte(0x09,0xFF);	
	
	
	HDMI_WriteI2C_Byte(0xFF,0x60);
	HDMI_WriteI2C_Byte(0x0e,0xC7);													/*reset PI */
	HDMI_WriteI2C_Byte(0x09,0x0F);													/*reset RX,CDR */
	nrf_delay_ms(10);
	HDMI_WriteI2C_Byte(0x0e,0xFF);													/*release PI */
	nrf_delay_ms(10);
	HDMI_WriteI2C_Byte(0x09,0x8F);													/*release RX */  
	nrf_delay_ms(10);
	HDMI_WriteI2C_Byte(0x09,0xFF);													/*release CDR */  		
	nrf_delay_ms(50);
}

bool LT8619C_ClkDet(void)
{
    u8 read_data_1/*,read_data_2*/;
				
    HDMI_WriteI2C_Byte(0xFF,0x80);
    if (HDMI_ReadI2C_Byte(0x44)&0x08) 
    {
        if(!pLT8619C_RXStatus->flag_RXClkStable)
        {
            pLT8619C_RXStatus->flag_RXClkStable = !pLT8619C_RXStatus->flag_RXClkStable;
            HDMI_WriteI2C_Byte(0xFF,0x60);
            read_data_1 = HDMI_ReadI2C_Byte(0x97);
            HDMI_WriteI2C_Byte(0x97,read_data_1&0x3f);
            HDMI_WriteI2C_Byte(0xFF,0x80);
            HDMI_WriteI2C_Byte(0x1b,0x00);
	#if 0
            HDMI_WriteI2C_Byte(0xFF,0x60);
            read_data_1 = HDMI_ReadI2C_Byte(0x0e);
            read_data_2 = HDMI_ReadI2C_Byte(0x09);

            HDMI_WriteI2C_Byte(0x0e,read_data_1&0x87);
            HDMI_WriteI2C_Byte(0x09,read_data_2&0x8f);
            nrf_delay_ms(5);
            HDMI_WriteI2C_Byte(0x0e,read_data_1|0x40);
            nrf_delay_ms(5);
            HDMI_WriteI2C_Byte(0x09,read_data_2|0x70);
            HDMI_WriteI2C_Byte(0x0e,read_data_1|0x38);
            HDMI_WriteI2C_Byte(0x0e,0xfd);
            HDMI_WriteI2C_Byte(0x0e,0xff);
	#endif
					
						LT8619C_RX_Reset();
						
						HDMI_WriteI2C_Byte(0xFF,0x60);					
            HDMI_WriteI2C_Byte(0x0e,0xfd);
            HDMI_WriteI2C_Byte(0x0e,0xff);					
					
						nrf_delay_ms(5);
						HDMI_WriteI2C_Byte(0xFF,0x80);
            read_data_1 = HDMI_ReadI2C_Byte(0x87)&0x10;
						
            if( read_data_1 )
            {	
								
                pLT8619C_RXStatus->flag_RXPLLLocked = TRUE;
                NRF_LOG_INFO("\r\nLT8619C clk detected!!!");
                NRF_LOG_INFO("\r\nLT8619C pll lock!!!");
								return TRUE;
            }
            else
            {
                pLT8619C_RXStatus->flag_RXPLLLocked = FALSE;
                memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));
                NRF_LOG_INFO("\r\nLT8619C clk detected!!!");
                NRF_LOG_INFO("\r\nLT8619C pll unlock#####");
                
								return FALSE;
            }
        }
        else
        {
            HDMI_WriteI2C_Byte(0xFF,0x80);
            read_data_1 = HDMI_ReadI2C_Byte(0x87)&0x10;
            
            if( read_data_1 )
            {
                pLT8619C_RXStatus->flag_RXPLLLocked = TRUE;
                return TRUE;
            }
            else
            {
                pLT8619C_RXStatus->flag_RXPLLLocked = FALSE;
                memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));
                NRF_LOG_INFO("\r\nLT8619C pll unlock#####$$");
                return FALSE;
            }
        }
        
    }
    else 
    {
        if( pLT8619C_RXStatus->flag_RXClkStable )
        {
            NRF_LOG_INFO("\r\nLT8619C clk disappear!!!");
        }
        memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));
        return FALSE;
    }
}

void LT8619C_GetInputInfo(void)
{
    u8 loop_num,read_data;
		
		
    HDMI_WriteI2C_Byte(0xFF,0x80);
    if( pLT8619C_RXStatus->flag_RXClkStable && pLT8619C_RXStatus->flag_RXPLLLocked)
    { 
//			NRF_LOG_INFO("\r\nHsync check start: ");
        if( HDMI_ReadI2C_Byte(0x13)&0x01 )
        {		
//						NRF_LOG_INFO("\r\nLT8619C 8013[0]=1 !!!#####");	
            if( !pLT8619C_RXStatus->Flag_HsyncStable )
            {			
                pLT8619C_RXStatus->Flag_HsyncStable = TRUE;
                for(loop_num=0; loop_num<8; loop_num++)
                {
//										NRF_LOG_INFO("\r\nHsync check num: ");
//										Debug_DispNum(loop_num);
//                    nrf_delay_ms(20);
                    if(!(HDMI_ReadI2C_Byte(0x13)&0x01))
                    {
												NRF_LOG_INFO("\r\nLT8619C 8013[0]=0 !!!#####");	
                        pLT8619C_RXStatus->Flag_HsyncStable = FALSE;																				
												NRF_LOG_INFO("\r\nLT8619C Hsync stable Fail #####");	
                        break;
                    }
                }

                if( pLT8619C_RXStatus->Flag_HsyncStable )
                {
										
											
                    HDMI_WriteI2C_Byte(0xFF,0x60);
                    read_data = HDMI_ReadI2C_Byte(0x0D);
                    HDMI_WriteI2C_Byte(0x0D,read_data&0xf8);  //reset LVDS/BT fifo
                    HDMI_WriteI2C_Byte(0x0D,read_data|0x06);
                    HDMI_WriteI2C_Byte(0x0D,read_data|0x01);

                    NRF_LOG_INFO("\r\nLT8619C Hsync stable!!!");
					
                }
            }
        }
        else
        {			
						 
            if( pLT8619C_RXStatus->Flag_HsyncStable )
            {
              NRF_LOG_INFO("\r\nLT8619C Hsync stable to unstable#####");		
						}	
						pLT8619C_RXStatus->Flag_HsyncStable = FALSE;
						
						NRF_LOG_INFO("\r\nLT8619C Hsync always unstable#####");
//						memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));
							
        }
    }

    if( pLT8619C_RXStatus->Flag_HsyncStable )
    {
        read_data = HDMI_ReadI2C_Byte(0x13);
        pLT8619C_RXStatus->input_hdmimode = (read_data&0x02)?(TRUE):(FALSE);
        if( pLT8619C_RXStatus->input_hdmimode )
        {
            pLT8619C_RXStatus->input_vic         = HDMI_ReadI2C_Byte(0x74)&0x7f;
            pLT8619C_RXStatus->input_colorspace  = HDMI_ReadI2C_Byte(0x71)&0x60;
            pLT8619C_RXStatus->input_colordepth  = HDMI_ReadI2C_Byte(0x16)&0xf0;
            pLT8619C_RXStatus->input_colorimetry = HDMI_ReadI2C_Byte(0x72)&0xc0;
            pLT8619C_RXStatus->input_ex_colorimetry = HDMI_ReadI2C_Byte(0x73)&0x70;
            pLT8619C_RXStatus->input_QuantRange  = HDMI_ReadI2C_Byte(0x73)&0x0c;
            pLT8619C_RXStatus->input_PRfactor    = (HDMI_ReadI2C_Byte(0x75)&0x0f);
            if( pLT8619C_RXStatus->input_PRfactor == 1 )
            {
                HDMI_WriteI2C_Byte(0xFF,0x60);
                read_data = HDMI_ReadI2C_Byte(0x97);
                HDMI_WriteI2C_Byte(0x97,read_data|0x40);
                HDMI_WriteI2C_Byte(0xFF,0x80);
                HDMI_WriteI2C_Byte(0x1b,0x20);
            }
            else if( pLT8619C_RXStatus->input_PRfactor == 3 )
            {
                HDMI_WriteI2C_Byte(0xFF,0x60);
                read_data = HDMI_ReadI2C_Byte(0x97);
                HDMI_WriteI2C_Byte(0x97,read_data|0x80);
                HDMI_WriteI2C_Byte(0xFF,0x80);
                HDMI_WriteI2C_Byte(0x1b,0x60);
            }
            else
            {
                HDMI_WriteI2C_Byte(0xFF,0x60);
                read_data = HDMI_ReadI2C_Byte(0x97);
                HDMI_WriteI2C_Byte(0x97,read_data&0x3f);
                HDMI_WriteI2C_Byte(0xFF,0x80);
                HDMI_WriteI2C_Byte(0x1b,0x00);
            }
        }
        else
        {
            pLT8619C_RXStatus->input_vic = 0;
            pLT8619C_RXStatus->input_colorspace = COLOR_RGB;
            pLT8619C_RXStatus->input_colordepth = 0;
            pLT8619C_RXStatus->input_colorimetry = ITU_709;
            pLT8619C_RXStatus->input_ex_colorimetry = 0;
            pLT8619C_RXStatus->input_QuantRange = FULL_RANGE;
            pLT8619C_RXStatus->input_PRfactor = 0;
            HDMI_WriteI2C_Byte(0xFF,0x60);
            read_data = HDMI_ReadI2C_Byte(0x97);
            HDMI_WriteI2C_Byte(0x97,read_data&0x3f);
            HDMI_WriteI2C_Byte(0xFF,0x80);
            HDMI_WriteI2C_Byte(0x1b,0x00);
        }

    }
}


void LT8619C_CSCConversion(void)
{
  
        HDMI_WriteI2C_Byte(0xFF,0x60);
        HDMI_WriteI2C_Byte(0x07,0xfe);
        if( LT8619C_OUTPUTCOLOR == COLOR_RGB )
        {
            if( pLT8619C_RXStatus->input_colorspace == COLOR_RGB )
            {
                HDMI_WriteI2C_Byte(0x52,0x00);
                if( pLT8619C_RXStatus->input_QuantRange == LIMIT_RANGE )
                {
                    HDMI_WriteI2C_Byte(0x53,0x08);
                }
                else
                {
                    HDMI_WriteI2C_Byte(0x53,0x00);
                }
            }
            else //input_colorspace = COLOR_YCBCR444 or COLOR_YCBCR422 or <ELSE>.
            {
                if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR422 )
                {
                    HDMI_WriteI2C_Byte(0x52,0x01);
                }
                else
                {
                    HDMI_WriteI2C_Byte(0x52,0x00);
                }
                if( pLT8619C_RXStatus->input_QuantRange == LIMIT_RANGE )
                {                                                     
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x53,0x50);//output to 0~255
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x53,0x70);//output to 0~255
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x53,0x70);
                    }
                }
                else if( pLT8619C_RXStatus->input_QuantRange == FULL_RANGE )
                {
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x53,0x40);
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x53,0x60);
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x53,0x60);
                    }
                }
                else  //DEFAULT_RANGE or RESERVED_VAL
                {
                    HDMI_WriteI2C_Byte(0x53,0x60);
                }
            }
        }
        else if( LT8619C_OUTPUTCOLOR == COLOR_YCBCR444 )
        {
            if( pLT8619C_RXStatus->input_colorspace == COLOR_RGB )
            {
                HDMI_WriteI2C_Byte(0x53,0x00);
                if( pLT8619C_RXStatus->input_QuantRange == LIMIT_RANGE )
                {
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x08);
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x28);
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x52,0x28);
                    }
                }
                else if( pLT8619C_RXStatus->input_QuantRange == FULL_RANGE )
                {
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x18);
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x38);
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x52,0x38);
                    }
                }
                else  //DEFAULT_RANGE or RESERVED_VAL
                {
                    HDMI_WriteI2C_Byte(0x52,0x38);
                }
            }
            else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR444 )
            {
                HDMI_WriteI2C_Byte(0x52,0x00);
                HDMI_WriteI2C_Byte(0x53,0x00);
            }
            else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR422 )
            {
                HDMI_WriteI2C_Byte(0x52,0x01);
                HDMI_WriteI2C_Byte(0x53,0x00);
            }
        }
        else if( LT8619C_OUTPUTCOLOR == COLOR_YCBCR422 )
        {
            if( pLT8619C_RXStatus->input_colorspace == COLOR_RGB )
            {
                HDMI_WriteI2C_Byte(0x53,0x00);
                if( pLT8619C_RXStatus->input_QuantRange == LIMIT_RANGE )
                {
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x0a);
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x2a);
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x52,0x2a);
                    }
                }
                else if( pLT8619C_RXStatus->input_QuantRange == FULL_RANGE )
                {
                    if(pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x1a);
                    }
                    else if(pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                    {
                        HDMI_WriteI2C_Byte(0x52,0x3a);
                    }
                    else  //input_colorimetry = NO_DATA or EXTENDED_COLORIETRY
                    {
                        HDMI_WriteI2C_Byte(0x52,0x3a);
                    }
                }
                else  //DEFAULT_RANGE or RESERVED_VAL
                {
                    HDMI_WriteI2C_Byte(0x52,0x3a);
                }
            }
            else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR444 )
            {
                HDMI_WriteI2C_Byte(0x52,0x02);
                HDMI_WriteI2C_Byte(0x53,0x00);
            }
            else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR422 )
            {
                HDMI_WriteI2C_Byte(0x52,0x00);
                HDMI_WriteI2C_Byte(0x53,0x00);
            }
        }
}


bool LT8619C_VideoChange(void)
{
    u16  h_total_tmp,v_total_tmp;
    HDMI_WriteI2C_Byte(0xFF,0x60);
    h_total_tmp     = ((u16)HDMI_ReadI2C_Byte(0x1e))<<8;
    h_total_tmp    += HDMI_ReadI2C_Byte(0x1f);
    v_total_tmp     = ((u16)(HDMI_ReadI2C_Byte(0x1c)&0x0f))<<8;
    v_total_tmp    += HDMI_ReadI2C_Byte(0x1d);
		NRF_LOG_INFO("\r\nv_total_tmp = %d", v_total_tmp);
		NRF_LOG_INFO("\r\nh_total_tmp = %d", h_total_tmp);
		NRF_LOG_INFO("\r\nv_total = %d", v_total);
		NRF_LOG_INFO("\r\nh_total = %d", h_total);
    if( (v_total_tmp != v_total) || (h_total_tmp != h_total) )
    {
        return 1;
    }
    return 0;
 /*
    u16  h_total_tmp,v_total_tmp;

    HDMI_WriteI2C_Byte(0xFF,0x60);
    h_total_tmp     = ((u16)HDMI_ReadI2C_Byte(0x1e))<<8;
    h_total_tmp    += HDMI_ReadI2C_Byte(0x1f);
    v_total_tmp     = ((u16)(HDMI_ReadI2C_Byte(0x1c)&0x0f))<<8;
    v_total_tmp    += HDMI_ReadI2C_Byte(0x1d);
	HDMI_WriteI2C_Byte(0xff,0x80);	
	color=HDMI_ReadI2C_Byte(0x71)&0x60;
	if( pLT8619C_RXStatus->input_hdmimode )
    {
        switch( pLT8619C_RXStatus->input_vic )
        {
            case 5:
            case 6: 
            case 7: 
            case 10: 
            case 11: 
            case 20: 
            case 21: 
            case 22:
            case 25:
            case 26:
					if( v_total_tmp%2 == 1 )
                    {
					    v_total_tmp = (v_total_tmp<<1)-1;
                    }
					else
                    {
						v_total_tmp = (v_total_tmp<<1)+1;
                    }
                break;

            default: 
                break;
        }

    }
    else  //dvi input
    {
    }
		NRF_LOG_INFO("\r\nv_total_tmp = ");
		Debug_DispNum(v_total_tmp);
		NRF_LOG_INFO("\r\nh_total_tmp = ");
		Debug_DispNum(h_total_tmp);
    if( (v_total_tmp != v_total) || (h_total_tmp != h_total) || (pLT8619C_RXStatus->input_colorspace != color) )
    {
        return 1;
    }
    return 0;
	*/
}

void LT8619C_VideoCheck(void)
{
    u8   tmp_read;
    if( !pLT8619C_RXStatus->Flag_HsyncStable )
    {
			 h_total=0;
			 v_total=0;
        return;
    }
    
    HDMI_WriteI2C_Byte(0xFF,0x60);

    h_active       = ((u16)HDMI_ReadI2C_Byte(0x22))<<8;
    h_active      += HDMI_ReadI2C_Byte(0x23);
    v_active       = ((u16)(HDMI_ReadI2C_Byte(0x20)&0x0f))<<8;
    v_active      += HDMI_ReadI2C_Byte(0x21);
    frame_counter  = ((u32)HDMI_ReadI2C_Byte(0x10))<<16;
    frame_counter += ((u32)HDMI_ReadI2C_Byte(0x11))<<8;
    frame_counter += HDMI_ReadI2C_Byte(0x12);

    h_syncwidth  = ((u16)(HDMI_ReadI2C_Byte(0x14)&0x0f))<<8;
    h_syncwidth += HDMI_ReadI2C_Byte(0x15);
    v_syncwidth  = HDMI_ReadI2C_Byte(0x13);
    h_bkporch    = ((u16)(HDMI_ReadI2C_Byte(0x18)&0x0f))<<8;
    h_bkporch   += HDMI_ReadI2C_Byte(0x19);
    v_bkporch    = HDMI_ReadI2C_Byte(0x16);
    h_total      = ((u16)HDMI_ReadI2C_Byte(0x1e))<<8;
    h_total     += HDMI_ReadI2C_Byte(0x1f);
    v_total      = ((u16)(HDMI_ReadI2C_Byte(0x1c)&0x0f))<<8;
    v_total     += HDMI_ReadI2C_Byte(0x1d);
    tmp_read     = HDMI_ReadI2C_Byte(0x24);
    h_syncpol    = tmp_read&0x01;
    v_syncpol    = (tmp_read&0x02)>>1;


#if 0
/***In order to avoid resolution error,Customers can change the judgment conditions according to the resolution used***/
//	if((h_active != 1920)||(v_active !=1080))
		if((h_active != lcd_timing.hact)||(v_active !=lcd_timing.vact)) 
		{	
			memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));	
		}
#endif
}

void LT8619C_BTSetting(void)
{
    u8 val_6060;
    u16 tmp_data;
    
	
    if( !pLT8619C_RXStatus->Flag_HsyncStable )
    {
        return;
    }

		LT8619C_LvdspllLock_Det();
		
    HDMI_WriteI2C_Byte(0xFF,0x60);
    val_6060 = HDMI_ReadI2C_Byte(0x60)&0xc7;

    //set BT TX h/vsync polarity
    if( h_syncpol )
    {
        val_6060 |= 0x20;
    }
    if( v_syncpol )
    {
        val_6060 |= 0x10;
    }

    //double the value of v_active&v_total when input is interlace resolution.
    //if user needs to support interlace format not listed here, please add that interlace format info here. 
		
    if( pLT8619C_RXStatus->input_hdmimode )
    {
        switch( pLT8619C_RXStatus->input_vic )
        {
            case 5:
            case 6: 
            case 7: 
            case 10: 
            case 11: 
            case 20: 
						  //      NRF_LOG_INFO("\r\nVIC20 ");
                    val_6060 |= 0x08;
                    v_active <<= 1;
                    if( v_total%2 == 1 )
                    {
                        v_total = (v_total<<1)-1;
                    }
                    else
                    {
                        v_total = (v_total<<1)+1;
                    }
                    HDMI_WriteI2C_Byte(0x68,23);
                break;

            case 21: 
            case 22:
            case 25:
            case 26:
						        NRF_LOG_INFO("\r\nVIC26 ");
                    val_6060 |= 0x08;
                    v_active <<= 1;
                    if( v_total%2 == 1 )
                    {
                        v_total = (v_total<<1)-1;
                    }
                    else
                    {
                        v_total = (v_total<<1)+1;
                    }
                    HDMI_WriteI2C_Byte(0x68,25);
                break;

            default: 
                    HDMI_WriteI2C_Byte(0x68,0x00);
                break;
        }

    }
    else  //dvi input
    {
        if( (h_active==1920) && (v_active==540) )
        {
            val_6060 |= 0x08;
            v_active <<= 1;
            if( v_total%2 == 1 )
            {
                v_total = (v_total<<1)-1;
            }
            else
            {
                v_total = (v_total<<1)+1;
            }
            HDMI_WriteI2C_Byte(0x68,23);
        }
        else if( (h_active==1440) && (v_active==240) )
        {
            val_6060 |= 0x08;
            v_active <<= 1;
            if( v_total%2 == 1 )
            {
                v_total = (v_total<<1)-1;
            }
            else
            {
                v_total = (v_total<<1)+1;
            }
            HDMI_WriteI2C_Byte(0x68,23);
        }
        else if( (h_active==1440) && (v_active==288) )
        {
            val_6060 |= 0x08;
            v_active <<= 1;
            if( v_total%2 == 1 )
            {
                v_total = (v_total<<1)-1;
            }
            else
            {
                v_total = (v_total<<1)+1;
            }
            HDMI_WriteI2C_Byte(0x68,25);
        }
    }

    HDMI_WriteI2C_Byte(0x60,val_6060);
    tmp_data = h_syncwidth + h_bkporch;
    HDMI_WriteI2C_Byte(0x61,(u8)(tmp_data>>8));
    HDMI_WriteI2C_Byte(0x62,(u8)tmp_data);
    tmp_data = h_active;
    HDMI_WriteI2C_Byte(0x63,(u8)(tmp_data>>8));
    HDMI_WriteI2C_Byte(0x64,(u8)tmp_data);
    tmp_data = h_total;
    HDMI_WriteI2C_Byte(0x65,(u8)(tmp_data>>8));
    HDMI_WriteI2C_Byte(0x66,(u8)tmp_data);
    tmp_data = v_syncwidth + v_bkporch;
    HDMI_WriteI2C_Byte(0x67,(u8)tmp_data);
    tmp_data = v_active;
    HDMI_WriteI2C_Byte(0x69,(u8)(tmp_data>>8));
    HDMI_WriteI2C_Byte(0x6a,(u8)tmp_data);
    tmp_data = v_total;
    HDMI_WriteI2C_Byte(0x6b,(u8)(tmp_data>>8));
    HDMI_WriteI2C_Byte(0x6c,(u8)tmp_data);
}

#if 1
void Debug_LT8619C_PrintRXinfo(void)
{
	u32 clk=0;
  static u16 print_en = 0;
	u32 audio_rate = 0;

    if( !pLT8619C_RXStatus->Flag_HsyncStable )
    {
        print_en = 0;
        return;
    }
		if( print_en != 3)
			{
        print_en++;
        
			if( print_en == 3)
				{	print_en = 0;
		if( pLT8619C_RXStatus->input_hdmimode )
		{
                NRF_LOG_INFO("\r\nInput is HDMI signal");

                NRF_LOG_INFO("\r\ninput_vic = %d",  pLT8619C_RXStatus->input_vic);
                
                if( pLT8619C_RXStatus->input_colorspace == COLOR_RGB )
                {
                    NRF_LOG_INFO("\r\ninput_colorspace is COLOR_RGB");
                }
                else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR444 )
                {
                    NRF_LOG_INFO("\r\ninput_colorspace is COLOR_YCBCR444");
                }
                else if( pLT8619C_RXStatus->input_colorspace == COLOR_YCBCR422 )
                {
                    NRF_LOG_INFO("\r\ninput_colorspace is COLOR_YCBCR422");
                }
                else
                {
                    NRF_LOG_INFO("\r\ninput_colorspace is unkonwn");
                }

                NRF_LOG_INFO("\r\ninput_colordepth = %d",pLT8619C_RXStatus->input_colordepth);
                
                if( pLT8619C_RXStatus->input_colorimetry == NO_DATA )
                {
                    NRF_LOG_INFO("\r\ninput_colorimetry is NO_DATA");
                }
                else if( pLT8619C_RXStatus->input_colorimetry == ITU_601 )
                {
                    NRF_LOG_INFO("\r\ninput_colorimetry is ITU_601");
                }
                else if( pLT8619C_RXStatus->input_colorimetry == ITU_709 )
                {
                    NRF_LOG_INFO("\r\ninput_colorimetry is ITU_709");
                }
                else
                {
                    NRF_LOG_INFO("\r\ninput_colorimetry is EXTENDED_COLORIETRY");
                }

                if( pLT8619C_RXStatus->input_colorimetry == EXTENDED_COLORIETRY )
                {
                    if( pLT8619C_RXStatus->input_ex_colorimetry == xvYCC601 )
                    {
                        NRF_LOG_INFO("\r\ninput_ex_colorimetry is xvYCC601");
                    }
                    else if( pLT8619C_RXStatus->input_ex_colorimetry == xvYCC709 )
                    {
                        NRF_LOG_INFO("\r\ninput_ex_colorimetry is xvYCC709");
                    }
                    else
                    {
                        NRF_LOG_INFO("\r\ninput_ex_colorimetry is FUTURE_COLORIETRY");
                    }
                }

                if( pLT8619C_RXStatus->input_QuantRange == DEFAULT_RANGE )
                {
                    NRF_LOG_INFO("\r\ninput_QuantRange is DEFAULT_RANGE");
                }
                else if( pLT8619C_RXStatus->input_QuantRange == LIMIT_RANGE )
                {
                    NRF_LOG_INFO("\r\ninput_QuantRange is LIMIT_RANGE");
                }
                else if( pLT8619C_RXStatus->input_QuantRange == FULL_RANGE )
                {
                    NRF_LOG_INFO("\r\ninput_QuantRange is FULL_RANGE");
                }
                else
                {
                    NRF_LOG_INFO("\r\ninput_QuantRange is RESERVED_VAL");
                }
                
                NRF_LOG_INFO("\r\ninput_PRfactor = %d",pLT8619C_RXStatus->input_PRfactor);
                
            }
            else
            {
                NRF_LOG_INFO("\r\nInput is DVI signal");
            }


            NRF_LOG_INFO("\r\n---------------- Input Timing Info -------------------");
      HDMI_WriteI2C_Byte(0xFF,0x80);
			clk=HDMI_ReadI2C_Byte(0x44)&0x07;
			clk<<=8;
			clk+=HDMI_ReadI2C_Byte(0x45);
			clk<<=8;
			clk+=HDMI_ReadI2C_Byte(0x46);
			NRF_LOG_INFO("\r\ntmds clk freq val: %d KHz", clk);
            /*
            HDMI_WriteI2C_Byte(0xFF,0x60);
            tmp_data = HDMI_ReadI2C_Byte(0x60);//0x6060 will be set in function [void LT8619C_BTSetting(void)].
            if( tmp_data & 0x08 )
            {
                NRF_LOG_INFO("\r\ninput is I format!!!");
            }
            else 
            {
                NRF_LOG_INFO("\r\ninput is P format!!!");
            }
            */
            NRF_LOG_INFO("\r\nh_active = %d", h_active);
            NRF_LOG_INFO("\r\nv_active = %d", v_active);
            NRF_LOG_INFO("\r\nh_syncwidth = %d", h_syncwidth);
            NRF_LOG_INFO("\r\nv_syncwidth = %d", v_syncwidth);
            NRF_LOG_INFO("\r\nh_bkporch = %d", h_bkporch);
            NRF_LOG_INFO("\r\nv_bkporch = %d", v_bkporch);
            NRF_LOG_INFO("\r\nh_total = %d", h_total);
            NRF_LOG_INFO("\r\nv_total = %d", v_total);
			NRF_LOG_INFO("\r\nframe_counter = %d", frame_counter);
            if(h_syncpol)
            {
                NRF_LOG_INFO("\r\nh_syncpol is positve!!! ");
            }
            else
            {
                NRF_LOG_INFO("\r\nh_syncpol is negative!!! ");
            }
            if(v_syncpol)
            {
                NRF_LOG_INFO("\r\nv_syncpol is positve!!! ");
            }
            else
            {
                NRF_LOG_INFO("\r\nv_syncpol is negative!!! ");
            }

			//  zll
			HDMI_WriteI2C_Byte(0xFF,0x80);
            audio_rate = ((HDMI_ReadI2C_Byte(0x11)&0x03) * 0x100) + HDMI_ReadI2C_Byte(0x12);
			NRF_LOG_INFO("\r\naudio_rate = %d kHz", audio_rate);
            NRF_LOG_INFO("\r\n------------------------------------------------------------");
		}
	}			
}
#endif

void LT8619C_LvdspllLock_Det(void)
{  
		u8 read_data_1;
	  u8 check_num = 0;
//		NRF_LOG_INFO("\r\nLVDSPLL status Det ing");
		HDMI_WriteI2C_Byte(0xFF,0x80);
		while((HDMI_ReadI2C_Byte(0x87)&0x20)==0x00)//Output LVDSPLL unlock status
		{
			HDMI_WriteI2C_Byte(0xFF,0x60);
			read_data_1 = HDMI_ReadI2C_Byte(0x0e);
			HDMI_WriteI2C_Byte(0x0e,read_data_1&0xFD);//LVDSPLL soft reset
			nrf_delay_ms(5);
			HDMI_WriteI2C_Byte(0x0e,0xFF);
			
			HDMI_WriteI2C_Byte(0xFF,0x80);
			
			check_num++;
			if(check_num > 3)
			{
				break;
			}
		}
	
}


bool LvdsData_check(void)
{
//	u8 read_data1,read_data2;
	u16 i,LVDScheck_bit0;
	u16 x=0;


	for ( i = 0; i < 200; i++ )
	{		
		HDMI_WriteI2C_Byte(0xFF,0x60);
		LVDScheck_bit0=HDMI_ReadI2C_Byte(0x92)&0x01;
		if(LVDScheck_bit0 == 0)
		{
			x++;
		}
	}
#if 0	
		HDMI_WriteI2C_Byte(0xFF,0x60);
		read_data1= HDMI_ReadI2C_Byte(0x92);
		read_data2= HDMI_ReadI2C_Byte(0x0D);

		NRF_LOG_INFO("\r\nLVDS_data_checknum1: ");
		Debug_DispNum(x);	
		NRF_LOG_INFO("\r\n1_0x6092: ");
		Debug_DispNum(read_data1);			
		NRF_LOG_INFO("\r\n1_0x600D: ");
		Debug_DispNum(read_data2);			
#endif
			
	if((x == 200)||(x == 0))
	{
#if 0		
		HDMI_WriteI2C_Byte(0xFF,0x60);
		read_data1= HDMI_ReadI2C_Byte(0x92);
		read_data2= HDMI_ReadI2C_Byte(0x0D);	
		NRF_LOG_INFO("\r\nLVDS_data_checknum2: ");
		Debug_DispNum(x);	
		NRF_LOG_INFO("\r\2_n0x6092: ");
		Debug_DispNum(read_data1);			
		NRF_LOG_INFO("\r\2_n0x600D: ");		  
	  Debug_DispNum(read_data2);	
#endif	
		
		return FALSE;
		
	}
	else
	{
		return TRUE;
	}

	
}

void LT8619C_LVDSData_Det(void)
{  
	u8 read_data/*,read_data1,read_data2*/;
	u8 n=0;
	do
	{
			if(!LvdsData_check())
		{
			HDMI_WriteI2C_Byte(0xFF,0x60);
			read_data = HDMI_ReadI2C_Byte(0x0D);
			HDMI_WriteI2C_Byte(0x0D,read_data&0xf8);  //reset LVDS/BT fifo
			nrf_delay_ms(10);
			HDMI_WriteI2C_Byte(0x0D,read_data|0x06);
			HDMI_WriteI2C_Byte(0x0D,read_data|0x01);
			
			n++;			
#if 0			
			NRF_LOG_INFO("\r\nReset_LVDS_FIFO_SUCCESS ");
			HDMI_WriteI2C_Byte(0xFF,0x60);
			read_data1= HDMI_ReadI2C_Byte(0x92);
			read_data2= HDMI_ReadI2C_Byte(0x0D);
			NRF_LOG_INFO("\r\n4_0x6092: ");
			Debug_DispNum(read_data1);			
			NRF_LOG_INFO("\r\n4_0x600D: ");
			Debug_DispNum(read_data2);		
#endif
			
		}
			
		if(n>4)
		{			
			memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));				
			break;
		}		

	}
	while(!LvdsData_check());
		
}	

void LT8619C_MainLoop(void)
{
    if( LT8619C_ClkDet() )
	{
		nrf_delay_ms(100);
	  LT8619C_GetInputInfo();
		LT8619C_CSCConversion();
		pLT8619C_RXStatus->Flag_HsyncStable = true;
		LT8619C_VideoCheck();
		LT8619C_BTSetting();
		Debug_LT8619C_PrintRXinfo();

/***The Function LT8619C_LVDSData_Det() Only use for 2port LVDS out ,and can't use for LT8619C U3C***/		
		#if 0
		if(LT8619C_OUTPUTMODE ==  OUTPUT_LVDS_2_PORT)
		{
		   LT8619C_LVDSData_Det();
		}		
		#endif
/****************************************************************************************************/			
	
	}

}

bool LT8619C_CheckChipID(void)
{
    HDMI_WriteI2C_Byte(0xFF,0x60);
    if( (HDMI_ReadI2C_Byte(0x00)==0x16) && (HDMI_ReadI2C_Byte(0x01)==0x04) )
    {
        NRF_LOG_INFO("\r\nChipID is OK:0x1604");
        return TRUE;
    }
    else
    {
        NRF_LOG_INFO("\r\nChipID Fail!!!!");
        return FALSE;
    }
}

void LT8619C_Init(void)
{
    lt8619c_i2c_init();

    pLT8619C_RXStatus = &LT8619C_RXStatus;
    memset(pLT8619C_RXStatus, 0, sizeof(_LT8619C_RXStatus));
    //LT8619C_Reset();                                             //lt8619c hardware reset
    nrf_delay_ms(10);
    LT8619C_CheckChipID();										 //read chip id:0x16 0x04
    LT8619C_SetHPD(Low);
    LT8619C_EDID_Dtb_Block_Calc(ONCHIP_EDID+0x36,&lcd_timing);
    ONCHIP_EDID[127]=LT8619C_EDID_Check_Sum(0,&ONCHIP_EDID[0]);  //edid_check_sum;
    LT8619C_EDIDSet(ONCHIP_EDID);
    nrf_delay_ms(300);//100ms
    LT8619C_SetHPD(High);

#ifdef USE_EXTERNAL_HDCPKEY
    LT8619C_LoadHDCPKey();
#endif

    LT8619C_RXInit();
    LT8619C_Audio_Init();
}
